import {
  require_jsx_runtime
} from "./chunk-V2S5DJPG.js";
import {
  __commonJS,
  require_react
} from "./chunk-UZX524IT.js";

// node_modules/hero-slider/dist/modules/Manager.js
var require_Manager = __commonJS({
  "node_modules/hero-slider/dist/modules/Manager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsxRuntime = require_jsx_runtime();
    var React = require_react();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var React__default = _interopDefaultLegacy(React);
    function isMobile() {
      const isBrowser = typeof window !== "undefined";
      if (isBrowser) {
        if (navigator && /Mobi|Android/i.test(navigator.userAgentData || navigator.userAgent))
          return true;
        else
          return false;
      }
      return false;
    }
    var defaultProps = {
      isMobile: isMobile()
    };
    var ManagerStateContext = React__default["default"].createContext(void 0);
    function managerReducer(state, action) {
      switch (action.type) {
        case "update-is-mobile": {
          return Object.assign(Object.assign({}, state), { isMobile: state.isMobile });
        }
        case "register-slide": {
          const { slides } = state;
          if (slides.has(action.payload.ref))
            return Object.assign(Object.assign({}, state), { totalSlides: slides.size });
          slides.set(action.payload.ref, {
            ref: action.payload.ref,
            number: slides.size + 1,
            label: action.payload.label
          });
          return { isMobile: state.isMobile, slides, totalSlides: slides.size };
        }
        case "remove-slide": {
          const { slides } = state;
          if (!slides.has(action.payload))
            return state;
          slides.delete(action.payload);
          return { isMobile: state.isMobile, slides, totalSlides: slides.size };
        }
        default: {
          throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);
        }
      }
    }
    function ManagerProvider({ children, manager }) {
      var _a;
      const [state, dispatch] = React__default["default"].useReducer(managerReducer, {
        isMobile: (_a = manager === null || manager === void 0 ? void 0 : manager.isMobile) !== null && _a !== void 0 ? _a : defaultProps.isMobile,
        slides: /* @__PURE__ */ new Map(),
        totalSlides: 0
      });
      const getSlide = (ref) => {
        return state.slides.get(ref);
      };
      const registerSlide = (ref, label) => {
        dispatch({
          type: "register-slide",
          payload: {
            ref,
            label
          }
        });
      };
      const removeSlide = (ref) => {
        dispatch({
          type: "remove-slide",
          payload: ref
        });
      };
      React__default["default"].useEffect(() => {
        if (typeof (manager === null || manager === void 0 ? void 0 : manager.isMobile) === "boolean")
          dispatch({
            type: "update-is-mobile",
            payload: manager === null || manager === void 0 ? void 0 : manager.isMobile
          });
      }, [manager === null || manager === void 0 ? void 0 : manager.isMobile]);
      const value = {
        state,
        getSlide,
        registerSlide,
        removeSlide
      };
      return jsxRuntime.jsx(ManagerStateContext.Provider, Object.assign({ value }, { children }));
    }
    function useManager() {
      const context = React__default["default"].useContext(ManagerStateContext);
      if (context === void 0) {
        throw new Error("useManager must be used within a ManagerProvider");
      }
      return context;
    }
    exports.ManagerProvider = ManagerProvider;
    exports.useManager = useManager;
  }
});

// node_modules/hero-slider/dist/modules/Controller.js
var require_Controller = __commonJS({
  "node_modules/hero-slider/dist/modules/Controller.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsxRuntime = require_jsx_runtime();
    var React = require_react();
    var Manager = require_Manager();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var React__default = _interopDefaultLegacy(React);
    var defaultProps = {
      slidingDuration: 500,
      slidingDelay: 200,
      initialSlide: 1
    };
    var ControllerStateContext = React__default["default"].createContext(void 0);
    function settingsReducer(state, action) {
      switch (action.type) {
        case "start-sliding": {
          if (state.isSliding)
            return state;
          return Object.assign(Object.assign({}, state), { isSliding: true, activeSlide: action.payload.nextSlide, prevActiveSlide: state.activeSlide, slidingDirection: action.payload.slidingDirection });
        }
        case "finish-sliding": {
          if (!state.isSliding)
            return state;
          return Object.assign(Object.assign({}, state), { isSliding: false, slidingDirection: void 0 });
        }
        case "set-delay-timeout": {
          return Object.assign(Object.assign({}, state), { delayTimeout: action.payload });
        }
        case "set-sliding-timeout": {
          return Object.assign(Object.assign({}, state), { slidingTimeout: action.payload });
        }
        default: {
          throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);
        }
      }
    }
    function ControllerProvider({ children, controller }) {
      var _a, _b;
      const params = {
        slidingDuration: (_a = controller === null || controller === void 0 ? void 0 : controller.slidingDuration) !== null && _a !== void 0 ? _a : defaultProps.slidingDuration,
        slidingDelay: (_b = controller === null || controller === void 0 ? void 0 : controller.slidingDelay) !== null && _b !== void 0 ? _b : defaultProps.slidingDelay,
        initialSlide: (controller === null || controller === void 0 ? void 0 : controller.initialSlide) || defaultProps.initialSlide
      };
      const [state, dispatch] = React__default["default"].useReducer(settingsReducer, {
        activeSlide: params.initialSlide,
        prevActiveSlide: 0,
        isSliding: false,
        slidingDirection: void 0,
        delayTimeout: void 0,
        slidingTimeout: void 0
      });
      const { state: manager } = Manager.useManager();
      const getNextSlide = (aSlide = state.activeSlide) => {
        const lastSlide = manager.totalSlides;
        const isNotLastSlide = aSlide <= lastSlide - 1;
        let nextSlide;
        if (isNotLastSlide)
          nextSlide = aSlide + 1;
        else
          nextSlide = 1;
        return nextSlide;
      };
      const getPreviousSlide = (aSlide = state.activeSlide) => {
        const lastSlide = manager.totalSlides;
        const isNotFirstSlide = aSlide > 1;
        let prevSlide;
        if (isNotFirstSlide)
          prevSlide = aSlide - 1;
        else
          prevSlide = lastSlide;
        return prevSlide;
      };
      const getSlidingCycleDuration = () => {
        return (params.slidingDuration + params.slidingDelay) * 1.1;
      };
      const changeSlide = (nextSlide, slidingDirection) => {
        if (state.isSliding)
          return;
        if (controller === null || controller === void 0 ? void 0 : controller.onBeforeSliding)
          controller.onBeforeSliding(state.activeSlide, nextSlide);
        dispatch({
          type: "start-sliding",
          payload: {
            nextSlide,
            slidingDirection
          }
        });
      };
      const goToNextSlide = () => {
        changeSlide(getNextSlide(state.activeSlide), "forward");
      };
      const goToPreviousSlide = () => {
        changeSlide(getPreviousSlide(state.activeSlide), "backward");
      };
      React__default["default"].useEffect(() => {
        if (controller === null || controller === void 0 ? void 0 : controller.goToNextSlidePointer)
          controller.goToNextSlidePointer.current = goToNextSlide;
      }, [controller === null || controller === void 0 ? void 0 : controller.goToNextSlidePointer, goToNextSlide]);
      React__default["default"].useEffect(() => {
        if (controller === null || controller === void 0 ? void 0 : controller.goToPreviousSlidePointer)
          controller.goToPreviousSlidePointer.current = goToPreviousSlide;
      }, [controller === null || controller === void 0 ? void 0 : controller.goToPreviousSlidePointer, goToNextSlide]);
      React__default["default"].useEffect(() => {
        const delayTimeout = setTimeout(() => {
          if (state.isSliding && (controller === null || controller === void 0 ? void 0 : controller.onSliding))
            controller.onSliding(state.activeSlide, state.prevActiveSlide);
        }, params.slidingDelay);
        const slidingTimeout = setTimeout(() => {
          dispatch({ type: "finish-sliding" });
          if (controller === null || controller === void 0 ? void 0 : controller.onAfterSliding)
            controller.onAfterSliding(state.activeSlide, state.prevActiveSlide);
        }, getSlidingCycleDuration());
        dispatch({
          type: "set-delay-timeout",
          payload: delayTimeout
        });
        dispatch({
          type: "set-sliding-timeout",
          payload: slidingTimeout
        });
        return () => {
          clearTimeout(delayTimeout);
          clearTimeout(slidingTimeout);
        };
      }, [state.activeSlide]);
      const value = {
        state,
        slidingDuration: params.slidingDuration,
        slidingDelay: params.slidingDelay,
        getNextSlide,
        getPreviousSlide,
        getSlidingCycleDuration,
        changeSlide,
        goToNextSlide,
        goToPreviousSlide
      };
      return jsxRuntime.jsx(ControllerStateContext.Provider, Object.assign({ value }, { children }));
    }
    function useController() {
      const context = React__default["default"].useContext(ControllerStateContext);
      if (context === void 0) {
        throw new Error("useController must be used within a ControllerProvider");
      }
      return context;
    }
    exports.ControllerProvider = ControllerProvider;
    exports.useController = useController;
  }
});

// node_modules/hero-slider/dist/modules/Accessibility.js
var require_Accessibility = __commonJS({
  "node_modules/hero-slider/dist/modules/Accessibility.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsxRuntime = require_jsx_runtime();
    var React = require_react();
    var Controller = require_Controller();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var React__default = _interopDefaultLegacy(React);
    exports.AccessibilityOrientation = void 0;
    (function(AccessibilityOrientation) {
      AccessibilityOrientation["VERTICAL"] = "vertical";
      AccessibilityOrientation["HORIZONTAL"] = "horizontal";
    })(exports.AccessibilityOrientation || (exports.AccessibilityOrientation = {}));
    var defaultProps = {
      shouldDisplayButtons: true,
      shouldSlideOnArrowKeypress: true,
      orientation: exports.AccessibilityOrientation.HORIZONTAL,
      thresholdToSlide: 50
    };
    var AccessibilityStateContext = React__default["default"].createContext(void 0);
    function accessibilityReducer(state, action) {
      switch (action.type) {
        case "start-motion": {
          return {
            initialX: action.payload.x,
            initialY: action.payload.y,
            currentX: void 0,
            currentY: void 0
          };
        }
        case "update-motion": {
          return {
            initialX: state.initialX,
            initialY: state.initialY,
            currentX: action.payload.x,
            currentY: action.payload.y
          };
        }
        case "end-motion": {
          return {
            initialX: void 0,
            initialY: void 0,
            currentX: void 0,
            currentY: void 0
          };
        }
        default: {
          throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);
        }
      }
    }
    function AccessibilityProvider({ children, accessibility }) {
      var _a, _b, _c;
      const params = {
        shouldDisplayButtons: (_a = accessibility === null || accessibility === void 0 ? void 0 : accessibility.shouldDisplayButtons) !== null && _a !== void 0 ? _a : defaultProps.shouldDisplayButtons,
        shouldSlideOnArrowKeypress: (_b = accessibility === null || accessibility === void 0 ? void 0 : accessibility.shouldSlideOnArrowKeypress) !== null && _b !== void 0 ? _b : defaultProps.shouldSlideOnArrowKeypress,
        orientation: (accessibility === null || accessibility === void 0 ? void 0 : accessibility.orientation) || defaultProps.orientation,
        thresholdToSlide: (_c = accessibility === null || accessibility === void 0 ? void 0 : accessibility.thresholdToSlide) !== null && _c !== void 0 ? _c : defaultProps.thresholdToSlide
      };
      const [state, dispatch] = React__default["default"].useReducer(accessibilityReducer, {
        initialX: void 0,
        initialY: void 0,
        currentX: void 0,
        currentY: void 0
      });
      const { goToNextSlide, goToPreviousSlide } = Controller.useController();
      const onTouchStartHandler = (event) => {
        dispatch({
          type: "start-motion",
          payload: {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY
          }
        });
      };
      const onTouchMoveHandler = (event) => {
        dispatch({
          type: "update-motion",
          payload: {
            x: event.touches[0].clientX,
            y: event.touches[0].clientY
          }
        });
      };
      const onTouchEndHandler = () => {
        const diffX = Number(state.initialX) - Number(state.currentX);
        const diffY = Number(state.initialY) - Number(state.currentY);
        const isSlidingHorizontally = Math.abs(diffX) > Math.abs(diffY);
        const isSliderSetHorizontally = params.orientation === exports.AccessibilityOrientation.HORIZONTAL;
        const isSliderSetVertically = params.orientation === exports.AccessibilityOrientation.VERTICAL;
        if (isSlidingHorizontally && isSliderSetHorizontally && Math.abs(diffX) >= params.thresholdToSlide) {
          const isSwipingRight = diffX > 0;
          if (isSwipingRight)
            goToNextSlide();
          else
            goToPreviousSlide();
        } else if (!isSlidingHorizontally && isSliderSetVertically && Math.abs(diffY) >= params.thresholdToSlide) {
          const isSwipingUp = diffY > 0;
          if (isSwipingUp)
            goToNextSlide();
          else
            goToPreviousSlide();
        }
        dispatch({ type: "end-motion" });
      };
      const onArrowKeypressHandler = (e) => {
        if (!params.shouldSlideOnArrowKeypress)
          return;
        const code = e.key || e.code || e.keyCode;
        const isHorizontal = params.orientation === exports.AccessibilityOrientation.HORIZONTAL;
        switch (true) {
          case (isHorizontal && (code === "ArrowLeft" || code === 37)):
            goToPreviousSlide();
            break;
          case (isHorizontal && (code === "ArrowRight" || code === 39)):
            goToNextSlide();
            break;
          case (!isHorizontal && (code === "ArrowUp" || code === 38)):
            goToPreviousSlide();
            break;
          case (!isHorizontal && (code === "ArrowDown" || code === 40)):
            goToNextSlide();
            break;
        }
      };
      React__default["default"].useEffect(() => {
        window.addEventListener("keydown", onArrowKeypressHandler);
        return () => {
          window.removeEventListener("keydown", onArrowKeypressHandler);
        };
      }, [onArrowKeypressHandler]);
      const value = {
        state,
        shouldDisplayButtons: params.shouldDisplayButtons,
        orientation: params.orientation,
        onTouchStartHandler,
        onTouchMoveHandler,
        onTouchEndHandler
      };
      return jsxRuntime.jsx(AccessibilityStateContext.Provider, Object.assign({ value }, { children }));
    }
    function useAccessibility() {
      const context = React__default["default"].useContext(AccessibilityStateContext);
      if (context === void 0) {
        throw new Error("useAccessibility must be used within a AccessibilityProvider");
      }
      return context;
    }
    exports.AccessibilityProvider = AccessibilityProvider;
    exports.useAccessibility = useAccessibility;
  }
});

// node_modules/hero-slider/dist/HeroSlider.module.css.js
var require_HeroSlider_module_css = __commonJS({
  "node_modules/hero-slider/dist/HeroSlider.module.css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var HeroSliderModuleCss = { "Wrapper": "HeroSlider-module_Wrapper__TaeBr", "fade-in": "HeroSlider-module_fade-in__5as8N", "Container": "HeroSlider-module_Container__EBtOP", "Sliding_Fade_In": "HeroSlider-module_Sliding_Fade_In__mRgKX", "slide-fade-in": "HeroSlider-module_slide-fade-in__s5eQJ", "Sliding_Left_To_Right": "HeroSlider-module_Sliding_Left_To_Right__XPZWw", "slide-left-to-right": "HeroSlider-module_slide-left-to-right__mPnzQ", "Sliding_Right_To_Left": "HeroSlider-module_Sliding_Right_To_Left__62-PD", "slide-right-to-left": "HeroSlider-module_slide-right-to-left__qlxI2", "Sliding_Top_To_Bottom": "HeroSlider-module_Sliding_Top_To_Bottom__9qXf-", "slide-top-to-bottom": "HeroSlider-module_slide-top-to-bottom__2AGIn", "Sliding_Bottom_To_Top": "HeroSlider-module_Sliding_Bottom_To_Top__fuFNk", "slide-bottom-to-top": "HeroSlider-module_slide-bottom-to-top__fkZ3m" };
    exports["default"] = HeroSliderModuleCss;
  }
});

// node_modules/hero-slider/dist/modules/Animations.js
var require_Animations = __commonJS({
  "node_modules/hero-slider/dist/modules/Animations.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsxRuntime = require_jsx_runtime();
    var React = require_react();
    var HeroSlider_module = require_HeroSlider_module_css();
    var Accessibility = require_Accessibility();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var React__default = _interopDefaultLegacy(React);
    var SlidingAnimation;
    (function(SlidingAnimation2) {
      SlidingAnimation2["TOP_TO_BOTTOM"] = "top_to_bottom";
      SlidingAnimation2["BOTTOM_TO_TOP"] = "bottom_to_top";
      SlidingAnimation2["LEFT_TO_RIGHT"] = "left_to_right";
      SlidingAnimation2["RIGHT_TO_LEFT"] = "right_to_left";
      SlidingAnimation2["FADE"] = "fade";
    })(SlidingAnimation || (SlidingAnimation = {}));
    var SlidingAnimationCssClassMap = {
      [SlidingAnimation.FADE]: HeroSlider_module["default"].Sliding_Fade_In,
      [SlidingAnimation.TOP_TO_BOTTOM]: HeroSlider_module["default"].Sliding_Top_To_Bottom,
      [SlidingAnimation.BOTTOM_TO_TOP]: HeroSlider_module["default"].Sliding_Bottom_To_Top,
      [SlidingAnimation.LEFT_TO_RIGHT]: HeroSlider_module["default"].Sliding_Left_To_Right,
      [SlidingAnimation.RIGHT_TO_LEFT]: HeroSlider_module["default"].Sliding_Right_To_Left
    };
    var defaultProps = {
      slidingAnimation: "wipe",
      sliderFadeInDuration: 100,
      navbarFadeInDuration: 1e3,
      navbarFadeInDelay: 500,
      shouldManageAnimationSequence: true
    };
    var AnimationsStateContext = React__default["default"].createContext(void 0);
    function AnimationsProvider({ children, animations }) {
      var _a, _b, _c, _d;
      const { orientation } = Accessibility.useAccessibility();
      const params = {
        slidingAnimation: (animations === null || animations === void 0 ? void 0 : animations.slidingAnimation) || defaultProps.slidingAnimation,
        sliderFadeInDuration: (_a = animations === null || animations === void 0 ? void 0 : animations.sliderFadeInDuration) !== null && _a !== void 0 ? _a : defaultProps.sliderFadeInDuration,
        navbarFadeInDuration: (_b = animations === null || animations === void 0 ? void 0 : animations.navbarFadeInDuration) !== null && _b !== void 0 ? _b : defaultProps.navbarFadeInDuration,
        navbarFadeInDelay: (_c = animations === null || animations === void 0 ? void 0 : animations.navbarFadeInDelay) !== null && _c !== void 0 ? _c : defaultProps.navbarFadeInDelay,
        shouldManageAnimationSequence: (_d = animations === null || animations === void 0 ? void 0 : animations.shouldManageAnimationSequence) !== null && _d !== void 0 ? _d : defaultProps.shouldManageAnimationSequence
      };
      const getSlidingAnimationCssClass = (activeSlide, prevActiveSlide, slidingDirection) => {
        const getSlidingAnimation = () => {
          switch (params.slidingAnimation) {
            case "fade":
              return SlidingAnimation.FADE;
            case "wipe": {
              let direction;
              if (slidingDirection)
                direction = slidingDirection;
              else {
                const isSlidingForward = activeSlide > prevActiveSlide;
                direction = isSlidingForward ? "forward" : "backward";
              }
              if (direction === "forward")
                return orientation === Accessibility.AccessibilityOrientation.HORIZONTAL ? SlidingAnimation.RIGHT_TO_LEFT : SlidingAnimation.BOTTOM_TO_TOP;
              else
                return orientation === Accessibility.AccessibilityOrientation.HORIZONTAL ? SlidingAnimation.LEFT_TO_RIGHT : SlidingAnimation.TOP_TO_BOTTOM;
            }
            default: {
              throw new Error(`Unhandled sliding animation: [${params.slidingAnimation}]`);
            }
          }
        };
        return SlidingAnimationCssClassMap[getSlidingAnimation()];
      };
      const value = {
        sliderFadeInDuration: params.sliderFadeInDuration,
        navbarFadeInDuration: params.sliderFadeInDuration,
        navbarFadeInDelay: params.sliderFadeInDuration,
        getSlidingAnimationCssClass
      };
      return jsxRuntime.jsx(AnimationsStateContext.Provider, Object.assign({ value }, { children }));
    }
    function useAnimations() {
      const context = React__default["default"].useContext(AnimationsStateContext);
      if (context === void 0) {
        throw new Error("useAnimations must be used within a AnimationsProvider");
      }
      return context;
    }
    exports.AnimationsProvider = AnimationsProvider;
    exports.useAnimations = useAnimations;
  }
});

// node_modules/hero-slider/dist/modules/ConsoleLogger.js
var require_ConsoleLogger = __commonJS({
  "node_modules/hero-slider/dist/modules/ConsoleLogger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ConsoleLogger = class _ConsoleLogger {
      constructor(levels) {
        this.levels = levels;
      }
      log(...data) {
        if (this.levels.verbose)
          console.log(...data);
      }
      info(...data) {
        if (this.levels.info)
          console.info(...data);
      }
      debug(...data) {
        if (this.levels.debug)
          console.debug(...data);
      }
      warn(...data) {
        if (this.levels.warnings)
          console.warn(...data);
      }
      error(...data) {
        if (this.levels.errors)
          console.error(...data);
      }
      static new(levels = {
        verbose: false,
        info: false,
        debug: false,
        warnings: true,
        errors: true
      }) {
        if (!this.instance)
          this.instance = new _ConsoleLogger(levels);
        else
          this.instance.levels = levels;
        return this.instance;
      }
    };
    exports["default"] = ConsoleLogger;
  }
});

// node_modules/hero-slider/dist/node_modules/.pnpm/react-intersection-observer@9.4.0_react@18.2.0/node_modules/react-intersection-observer/react-intersection-observer.modern.mjs.js
var require_react_intersection_observer_modern_mjs = __commonJS({
  "node_modules/hero-slider/dist/node_modules/.pnpm/react-intersection-observer@9.4.0_react@18.2.0/node_modules/react-intersection-observer/react-intersection-observer.modern.mjs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var React = require_react();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var React__namespace = _interopNamespace(React);
    var observerMap = /* @__PURE__ */ new Map();
    var RootIds = /* @__PURE__ */ new WeakMap();
    var rootId = 0;
    var unsupportedValue = void 0;
    function getRootId(root) {
      if (!root)
        return "0";
      if (RootIds.has(root))
        return RootIds.get(root);
      rootId += 1;
      RootIds.set(root, rootId.toString());
      return RootIds.get(root);
    }
    function optionsToId(options) {
      return Object.keys(options).sort().filter((key) => options[key] !== void 0).map((key) => {
        return `${key}_${key === "root" ? getRootId(options.root) : options[key]}`;
      }).toString();
    }
    function createObserver(options) {
      let id = optionsToId(options);
      let instance = observerMap.get(id);
      if (!instance) {
        const elements = /* @__PURE__ */ new Map();
        let thresholds;
        const observer = new IntersectionObserver((entries) => {
          entries.forEach((entry) => {
            var _elements$get;
            const inView = entry.isIntersecting && thresholds.some((threshold) => entry.intersectionRatio >= threshold);
            if (options.trackVisibility && typeof entry.isVisible === "undefined") {
              entry.isVisible = inView;
            }
            (_elements$get = elements.get(entry.target)) == null ? void 0 : _elements$get.forEach((callback) => {
              callback(inView, entry);
            });
          });
        }, options);
        thresholds = observer.thresholds || (Array.isArray(options.threshold) ? options.threshold : [options.threshold || 0]);
        instance = {
          id,
          observer,
          elements
        };
        observerMap.set(id, instance);
      }
      return instance;
    }
    function observe(element, callback, options = {}, fallbackInView = unsupportedValue) {
      if (typeof window.IntersectionObserver === "undefined" && fallbackInView !== void 0) {
        const bounds = element.getBoundingClientRect();
        callback(fallbackInView, {
          isIntersecting: fallbackInView,
          target: element,
          intersectionRatio: typeof options.threshold === "number" ? options.threshold : 0,
          time: 0,
          boundingClientRect: bounds,
          intersectionRect: bounds,
          rootBounds: bounds
        });
        return () => {
        };
      }
      const {
        id,
        observer,
        elements
      } = createObserver(options);
      let callbacks = elements.get(element) || [];
      if (!elements.has(element)) {
        elements.set(element, callbacks);
      }
      callbacks.push(callback);
      observer.observe(element);
      return function unobserve() {
        callbacks.splice(callbacks.indexOf(callback), 1);
        if (callbacks.length === 0) {
          elements.delete(element);
          observer.unobserve(element);
        }
        if (elements.size === 0) {
          observer.disconnect();
          observerMap.delete(id);
        }
      };
    }
    function useInView({
      threshold,
      delay,
      trackVisibility,
      rootMargin,
      root,
      triggerOnce,
      skip,
      initialInView,
      fallbackInView,
      onChange
    } = {}) {
      var _state$entry;
      const [ref, setRef] = React__namespace.useState(null);
      const callback = React__namespace.useRef();
      const [state, setState] = React__namespace.useState({
        inView: !!initialInView,
        entry: void 0
      });
      callback.current = onChange;
      React__namespace.useEffect(
        () => {
          if (skip || !ref)
            return;
          let unobserve = observe(ref, (inView, entry) => {
            setState({
              inView,
              entry
            });
            if (callback.current)
              callback.current(inView, entry);
            if (entry.isIntersecting && triggerOnce && unobserve) {
              unobserve();
              unobserve = void 0;
            }
          }, {
            root,
            rootMargin,
            threshold,
            // @ts-ignore
            trackVisibility,
            // @ts-ignore
            delay
          }, fallbackInView);
          return () => {
            if (unobserve) {
              unobserve();
            }
          };
        },
        // We break the rule here, because we aren't including the actual `threshold` variable
        // eslint-disable-next-line react-hooks/exhaustive-deps
        [
          // If the threshold is an array, convert it to a string, so it won't change between renders.
          // eslint-disable-next-line react-hooks/exhaustive-deps
          Array.isArray(threshold) ? threshold.toString() : threshold,
          ref,
          root,
          rootMargin,
          triggerOnce,
          skip,
          trackVisibility,
          fallbackInView,
          delay
        ]
      );
      const entryTarget = (_state$entry = state.entry) == null ? void 0 : _state$entry.target;
      React__namespace.useEffect(() => {
        if (!ref && entryTarget && !triggerOnce && !skip) {
          setState({
            inView: !!initialInView,
            entry: void 0
          });
        }
      }, [ref, entryTarget, triggerOnce, skip, initialInView]);
      const result = [setRef, state.inView, state.entry];
      result.ref = result[0];
      result.inView = result[1];
      result.entry = result[2];
      return result;
    }
    exports.observe = observe;
    exports.useInView = useInView;
  }
});

// node_modules/hero-slider/dist/modules/IntersectionObserver.js
var require_IntersectionObserver = __commonJS({
  "node_modules/hero-slider/dist/modules/IntersectionObserver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsxRuntime = require_jsx_runtime();
    var React = require_react();
    var reactIntersectionObserver_modern = require_react_intersection_observer_modern_mjs();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var React__default = _interopDefaultLegacy(React);
    var IntersectionObserverStateContext = React__default["default"].createContext(void 0);
    function IntersectionObserverProvider({ children }) {
      const [ref, inView] = reactIntersectionObserver_modern.useInView({ threshold: 0 });
      const value = {
        elementObservedRef: ref,
        isInView: inView
      };
      return jsxRuntime.jsx(IntersectionObserverStateContext.Provider, Object.assign({ value }, { children }));
    }
    function useIntersectionObserver() {
      const context = React__default["default"].useContext(IntersectionObserverStateContext);
      if (context === void 0) {
        throw new Error("useIntersectionObserver must be used within a IntersectionObserverProvider");
      }
      return context;
    }
    exports.IntersectionObserverProvider = IntersectionObserverProvider;
    exports.useIntersectionObserver = useIntersectionObserver;
  }
});

// node_modules/hero-slider/dist/modules/IntervalTimer.js
var require_IntervalTimer = __commonJS({
  "node_modules/hero-slider/dist/modules/IntervalTimer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IntervalState = void 0;
    (function(IntervalState) {
      IntervalState[IntervalState["IDLE"] = 0] = "IDLE";
      IntervalState[IntervalState["RUNNING"] = 1] = "RUNNING";
      IntervalState[IntervalState["PAUSED"] = 2] = "PAUSED";
      IntervalState[IntervalState["RESUME"] = 3] = "RESUME";
    })(exports.IntervalState || (exports.IntervalState = {}));
    var IntervalTimer = class _IntervalTimer {
      constructor(callback, interval, maxFires) {
        this.callback = callback;
        this.interval = interval;
        this.maxFires = maxFires;
        this.state = exports.IntervalState.IDLE;
        this.remaining = 0;
        this.fires = 0;
        this.pausedTime = 0;
        this.intervalHandler = () => {
          if (this.maxFires != null && this.fires !== 0 && this.fires >= this.maxFires) {
            this.stop();
          } else {
            this.lastTimeFired = /* @__PURE__ */ new Date();
            this.fires += 1;
            this.callback();
          }
        };
        this.timeoutHandler = () => {
          if (this.state !== exports.IntervalState.RESUME)
            return;
          this.pausedTime = 0;
          this.intervalHandler();
          this.start();
        };
        this.start = () => {
          this.timerId = setInterval(this.intervalHandler, this.interval);
          this.lastTimeFired = /* @__PURE__ */ new Date();
          this.state = exports.IntervalState.RUNNING;
        };
        this.stop = () => {
          if (this.state === 0)
            return;
          clearInterval(this.timerId);
          clearTimeout(this.resumeId);
          this.state = exports.IntervalState.IDLE;
        };
        this.reset = () => {
          this.stop();
          this.start();
        };
        this.pause = () => {
          if (this.state !== exports.IntervalState.RUNNING && this.state !== exports.IntervalState.RESUME)
            return;
          this.remaining = +this.interval - (+/* @__PURE__ */ new Date() - +(this.lastTimeFired || 0)) + +this.pausedTime;
          this.lastPauseTime = /* @__PURE__ */ new Date();
          clearInterval(this.timerId);
          clearTimeout(this.resumeId);
          this.state = exports.IntervalState.PAUSED;
        };
        this.resume = () => {
          if (this.state !== exports.IntervalState.PAUSED)
            return;
          const currentDate = /* @__PURE__ */ new Date();
          this.pausedTime = +this.pausedTime + +currentDate - +(this.lastPauseTime || 0);
          this.state = exports.IntervalState.RESUME;
          this.resumeId = setTimeout(this.timeoutHandler, this.remaining);
        };
        this.setInterval = (newInterval) => {
          if (this.state === 1) {
            this.pause();
            this.interval = newInterval;
            this.resume();
          } else {
            this.interval = newInterval;
          }
        };
        this.setMaxFires = (newMax) => {
          if (newMax != null && this.fires >= newMax) {
            this.stop();
          }
          this.maxFires = newMax;
        };
      }
      static new(callback, interval, maxFires = void 0) {
        if (!this.instance)
          this.instance = new _IntervalTimer(callback, interval, maxFires);
        else {
          this.instance.callback = callback;
          this.instance.interval = interval;
          this.instance.maxFires = maxFires;
        }
        return this.instance;
      }
    };
    exports["default"] = IntervalTimer;
  }
});

// node_modules/hero-slider/dist/modules/Autoplay.js
var require_Autoplay = __commonJS({
  "node_modules/hero-slider/dist/modules/Autoplay.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsxRuntime = require_jsx_runtime();
    var React = require_react();
    var ConsoleLogger = require_ConsoleLogger();
    var Controller = require_Controller();
    var IntersectionObserver2 = require_IntersectionObserver();
    var IntervalTimer = require_IntervalTimer();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var React__default = _interopDefaultLegacy(React);
    var logger = ConsoleLogger["default"].new();
    var defaultProps = {
      autoplayDuration: 8e3,
      autoplayDebounce: 4e3
    };
    var AutoplayStateContext = React__default["default"].createContext(void 0);
    function autoplayReducer(state, action) {
      switch (action.type) {
        case "pause": {
          return Object.assign(Object.assign({}, state), { isPausedByUser: true });
        }
        case "resume": {
          return Object.assign(Object.assign({}, state), { isPausedByUser: false });
        }
        case "set-debounce-timeout": {
          return Object.assign(Object.assign({}, state), { debounceTimeout: action.payload });
        }
        default: {
          throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);
        }
      }
    }
    function AutoplayProvider({ children, autoplay }) {
      var _a, _b;
      const params = {
        autoplayDuration: (_a = typeof autoplay === "object" ? autoplay === null || autoplay === void 0 ? void 0 : autoplay.autoplayDuration : void 0) !== null && _a !== void 0 ? _a : defaultProps.autoplayDuration,
        autoplayDebounce: (_b = typeof autoplay === "object" ? autoplay === null || autoplay === void 0 ? void 0 : autoplay.autoplayDebounce : void 0) !== null && _b !== void 0 ? _b : defaultProps.autoplayDebounce
      };
      const [state, dispatch] = React__default["default"].useReducer(autoplayReducer, {
        isPausedByUser: false,
        debounceTimeout: void 0
      });
      const { state: controller, changeSlide, getNextSlide, getSlidingCycleDuration } = Controller.useController();
      const slidingCycleDuration = getSlidingCycleDuration();
      const autoplayCycleDuration = Math.max(slidingCycleDuration, params.autoplayDuration);
      if (params.autoplayDuration < getSlidingCycleDuration())
        logger.warn("[Autoplay] The `autoplayDuration` is lower than the sliding cycle duration (the result of `slidingDuration + slidingDelay`).", "The sliding cycle duration will be used instead for the autoplay intervals.");
      const autoplayInstance = IntervalTimer["default"].new(() => {
        changeSlide(getNextSlide(controller.activeSlide));
      }, autoplayCycleDuration);
      const { isInView } = IntersectionObserver2.useIntersectionObserver();
      const debounce = () => {
        const isPausedOrIdle = autoplayInstance.state === IntervalTimer.IntervalState.IDLE || state.isPausedByUser;
        if (isPausedOrIdle)
          return;
        autoplayInstance.pause();
        if (state.debounceTimeout)
          clearTimeout(state.debounceTimeout);
        dispatch({
          type: "set-debounce-timeout",
          payload: setTimeout(autoplayInstance.resume, params.autoplayDebounce)
        });
      };
      const pause = () => {
        logger.debug("[Autoplay] Paused by user.");
        autoplayInstance.pause();
        dispatch({ type: "pause" });
      };
      const resume = () => {
        logger.debug("[Autoplay] Resumed by user.");
        autoplayInstance.resume();
        dispatch({ type: "resume" });
      };
      React__default["default"].useEffect(() => {
        if (state.isPausedByUser)
          clearTimeout(state.debounceTimeout);
        return () => {
        };
      }, [state.isPausedByUser]);
      React__default["default"].useEffect(() => {
        if (autoplay) {
          switch (true) {
            case state.isPausedByUser:
              break;
            case (!isInView && autoplayInstance.state !== IntervalTimer.IntervalState.IDLE):
              autoplayInstance.stop();
              logger.debug("[Autoplay] Stopped.");
              break;
            case (isInView && autoplayInstance.state === IntervalTimer.IntervalState.IDLE): {
              autoplayInstance.start();
              logger.debug("[Autoplay] Started.");
              break;
            }
            case (isInView && autoplayInstance.state === IntervalTimer.IntervalState.PAUSED): {
              autoplayInstance.resume();
              logger.debug("[Autoplay] Resumed.");
              break;
            }
          }
        } else if (autoplayInstance.state !== IntervalTimer.IntervalState.IDLE) {
          autoplayInstance.stop();
          logger.info("[Autoplay] Stopped.");
        }
      }, [autoplay, isInView]);
      React__default["default"].useEffect(() => {
        return () => {
          clearTimeout(state.debounceTimeout);
          autoplayInstance.stop();
        };
      }, []);
      React__default["default"].useEffect(() => {
        clearTimeout(state.debounceTimeout);
        return () => {
        };
      }, [controller.activeSlide]);
      const value = {
        state,
        autoplayState: autoplayInstance.state,
        debounce,
        pause,
        resume
      };
      return jsxRuntime.jsx(AutoplayStateContext.Provider, Object.assign({ value }, { children }));
    }
    function useAutoplay() {
      const context = React__default["default"].useContext(AutoplayStateContext);
      if (context === void 0) {
        throw new Error("useAutoplay must be used within a AutoplayProvider");
      }
      return context;
    }
    exports.AutoplayProvider = AutoplayProvider;
    exports.useAutoplay = useAutoplay;
  }
});

// node_modules/hero-slider/dist/modules/Layout.js
var require_Layout = __commonJS({
  "node_modules/hero-slider/dist/modules/Layout.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsxRuntime = require_jsx_runtime();
    var React = require_react();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var React__default = _interopDefaultLegacy(React);
    var mobileThreshold = 1024;
    var LayoutStateContext = React__default["default"].createContext(void 0);
    function layoutReducer(state, action) {
      var _a, _b;
      switch (action.type) {
        case "update-slider-dimensions": {
          return {
            slider: state.slider,
            width: (_a = state.slider.current) === null || _a === void 0 ? void 0 : _a.clientWidth,
            height: (_b = state.slider.current) === null || _b === void 0 ? void 0 : _b.clientHeight
          };
        }
        default: {
          throw new Error(`Unhandled action: [${JSON.stringify(action, null, 2)}]`);
        }
      }
    }
    function LayoutProvider({ children }) {
      const [state, dispatch] = React__default["default"].useReducer(layoutReducer, {
        slider: React__default["default"].useRef(null),
        width: void 0,
        height: void 0
      });
      React__default["default"].useEffect(() => {
        function updateSliderDimensions() {
          if (state.slider.current)
            dispatch({ type: "update-slider-dimensions" });
        }
        updateSliderDimensions();
        window.addEventListener("resize", updateSliderDimensions);
        return () => {
          window.removeEventListener("resize", updateSliderDimensions);
        };
      }, [state.slider.current]);
      const value = { state, mobileThreshold };
      return jsxRuntime.jsx(LayoutStateContext.Provider, Object.assign({ value }, { children }));
    }
    function useLayout() {
      const context = React__default["default"].useContext(LayoutStateContext);
      if (context === void 0)
        throw new Error("useLayout must be used within a LayoutProvider");
      return context;
    }
    exports.LayoutProvider = LayoutProvider;
    exports.useLayout = useLayout;
  }
});

// node_modules/hero-slider/dist/modules/Settings.js
var require_Settings = __commonJS({
  "node_modules/hero-slider/dist/modules/Settings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsxRuntime = require_jsx_runtime();
    var React = require_react();
    var ConsoleLogger = require_ConsoleLogger();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var React__default = _interopDefaultLegacy(React);
    var defaultProps = {
      sliderColor: "inherit",
      sliderStyle: {},
      navbarStyle: {
        color: void 0,
        activeColor: void 0
      }
    };
    var SettingsStateContext = React__default["default"].createContext(void 0);
    function SettingsProvider({ children, settings }) {
      const params = {
        sliderColor: (settings === null || settings === void 0 ? void 0 : settings.sliderColor) || defaultProps.sliderColor,
        sliderStyle: (settings === null || settings === void 0 ? void 0 : settings.sliderStyle) || defaultProps.sliderStyle,
        navbarStyle: (settings === null || settings === void 0 ? void 0 : settings.navbarStyle) || defaultProps.navbarStyle,
        debug: settings === null || settings === void 0 ? void 0 : settings.debug
      };
      React__default["default"].useEffect(() => {
        ConsoleLogger["default"].new(params.debug);
      }, [params.debug]);
      const value = params;
      return jsxRuntime.jsx(SettingsStateContext.Provider, Object.assign({ value }, { children }));
    }
    function useSettings() {
      const context = React__default["default"].useContext(SettingsStateContext);
      if (context === void 0) {
        throw new Error("useSettings must be used within a SettingsProvider");
      }
      return context;
    }
    exports.SettingsProvider = SettingsProvider;
    exports.useSettings = useSettings;
  }
});

// node_modules/hero-slider/dist/utils/composeCssClasses.js
var require_composeCssClasses = __commonJS({
  "node_modules/hero-slider/dist/utils/composeCssClasses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function composeCssClasses(...classes) {
      return classes.filter((i) => {
        if (!i)
          return false;
        else if (typeof i === "string")
          return true;
        else if (typeof i.useIf === "boolean")
          return i.useIf;
        else
          return true;
      }).map((i) => {
        if (typeof i === "string")
          return i;
        else
          return i.className;
      }).join(" ");
    }
    exports.composeCssClasses = composeCssClasses;
  }
});

// node_modules/hero-slider/dist/components/Buttons/index.module.css.js
var require_index_module_css = __commonJS({
  "node_modules/hero-slider/dist/components/Buttons/index.module.css.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ButtonsModuleCss = { "Wrapper": "index-module_Wrapper__ZIVLd", "Container": "index-module_Container__mtjRh", "Button": "index-module_Button__hkx4Z", "Horizontal": "index-module_Horizontal__8-P70", "Previous": "index-module_Previous__TaJVT", "Next": "index-module_Next__sFCHR", "Vertical": "index-module_Vertical__VyL0Y" };
    exports["default"] = ButtonsModuleCss;
  }
});

// node_modules/hero-slider/dist/components/Buttons/index.js
var require_Buttons = __commonJS({
  "node_modules/hero-slider/dist/components/Buttons/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsxRuntime = require_jsx_runtime();
    var Accessibility = require_Accessibility();
    var Controller = require_Controller();
    var Manager = require_Manager();
    var composeCssClasses = require_composeCssClasses();
    var index_module = require_index_module_css();
    function ArrowSvg() {
      return jsxRuntime.jsx("svg", Object.assign({ width: "60px", height: "60px", strokeWidth: "5", version: "1.1", viewBox: "0 0 129 129" }, { children: jsxRuntime.jsx("g", Object.assign({ fill: "currentColor" }, { children: jsxRuntime.jsx("path", { d: "m40.4,121.3c-0.8,0.8-1.8,1.2-2.9,1.2s-2.1-0.4-2.9-1.2c-1.6-1.6-1.6-4.2 0-5.8l51-51-51-51c-1.6-1.6-1.6-4.2 0-5.8 1.6-1.6 4.2-1.6 5.8,0l53.9,53.9c1.6,1.6 1.6,4.2 0,5.8l-53.9,53.9z" }) })) }));
    }
    function Buttons() {
      const { state: { isMobile } } = Manager.useManager();
      const { orientation } = Accessibility.useAccessibility();
      const { goToPreviousSlide, goToNextSlide } = Controller.useController();
      if (isMobile)
        return null;
      const isHorizontal = orientation === Accessibility.AccessibilityOrientation.HORIZONTAL;
      return jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("div", Object.assign({ "data-testid": "hero-slider-previous", className: composeCssClasses.composeCssClasses("hero-slider-previous", index_module["default"].Previous, index_module["default"].Wrapper, { className: index_module["default"].Horizontal, useIf: isHorizontal }, { className: index_module["default"].Vertical, useIf: !isHorizontal }) }, { children: jsxRuntime.jsx("div", Object.assign({ className: composeCssClasses.composeCssClasses("hero-slider-previous-container", index_module["default"].Container) }, { children: jsxRuntime.jsx("button", Object.assign({ "data-testid": "hero-slider-previous-button", className: composeCssClasses.composeCssClasses("hero-slider-previous-button", index_module["default"].Button), onClick: goToPreviousSlide }, { children: jsxRuntime.jsx(ArrowSvg, {}) })) })) })), jsxRuntime.jsx("div", Object.assign({ "data-testid": "hero-slider-next", className: composeCssClasses.composeCssClasses("hero-slider-next", index_module["default"].Next, index_module["default"].Wrapper, { className: index_module["default"].Horizontal, useIf: isHorizontal }, { className: index_module["default"].Vertical, useIf: !isHorizontal }) }, { children: jsxRuntime.jsx("div", Object.assign({ className: composeCssClasses.composeCssClasses("hero-slider-next-container", index_module["default"].Container) }, { children: jsxRuntime.jsx("button", Object.assign({ "data-testid": "hero-slider-next-button", className: composeCssClasses.composeCssClasses("hero-slider-next-button", index_module["default"].Button), onClick: goToNextSlide }, { children: jsxRuntime.jsx(ArrowSvg, {}) })) })) }))] });
    }
    exports["default"] = Buttons;
  }
});

// node_modules/hero-slider/dist/Orchestrator.js
var require_Orchestrator = __commonJS({
  "node_modules/hero-slider/dist/Orchestrator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsxRuntime = require_jsx_runtime();
    var index = require_Buttons();
    var HeroSlider_module = require_HeroSlider_module_css();
    var Accessibility = require_Accessibility();
    var Animations = require_Animations();
    var Autoplay = require_Autoplay();
    var ConsoleLogger = require_ConsoleLogger();
    var Controller = require_Controller();
    var IntersectionObserver2 = require_IntersectionObserver();
    var Layout = require_Layout();
    var Settings = require_Settings();
    var composeCssClasses = require_composeCssClasses();
    var logger = ConsoleLogger["default"].new();
    function Orchestrator({ className, width = "100%", height = "100vh", style, children }) {
      logger.info("[Orchestrator] rerender");
      const { shouldDisplayButtons } = Accessibility.useAccessibility();
      const { sliderFadeInDuration, navbarFadeInDuration, navbarFadeInDelay } = Animations.useAnimations();
      const { state: layout } = Layout.useLayout();
      const { slidingDuration, slidingDelay, getSlidingCycleDuration } = Controller.useController();
      const settings = Settings.useSettings();
      const { debounce } = Autoplay.useAutoplay();
      const { onTouchStartHandler, onTouchMoveHandler, onTouchEndHandler } = Accessibility.useAccessibility();
      const { elementObservedRef } = IntersectionObserver2.useIntersectionObserver();
      const cssVariables = {
        "--sliding-duration": `${slidingDuration}ms`,
        "--sliding-delay": `${slidingDelay}ms`,
        "--slide-transition-delay": `${getSlidingCycleDuration()}ms`,
        "--slider-width": layout.width ? `${layout.width}px` : void 0,
        "--slider-height": layout.height ? `${layout.height}px` : void 0,
        "--slider-color": settings.sliderColor,
        "--slider-fade-in-duration": `${sliderFadeInDuration}ms`,
        "--nav-fade-in-duration": `${navbarFadeInDuration}ms`,
        "--nav-fade-in-delay": `${navbarFadeInDelay}ms`,
        "--nav-background-color": settings.navbarStyle ? settings.navbarStyle.color : void 0,
        "--nav-active-color": settings.navbarStyle ? settings.navbarStyle.activeColor : void 0,
        "--mask-duration": `${getSlidingCycleDuration()}ms`
      };
      return jsxRuntime.jsx("div", Object.assign({ "data-testid": "hero-slider", className: composeCssClasses.composeCssClasses("hero-slider", className), ref: elementObservedRef }, { children: jsxRuntime.jsxs("div", Object.assign({ "data-testid": "hero-slider-wrapper", ref: layout.slider, className: composeCssClasses.composeCssClasses("hero-slider-wrapper", HeroSlider_module["default"].Wrapper), onTouchStart: onTouchStartHandler, onTouchMove: onTouchMoveHandler, onTouchEnd: onTouchEndHandler, onMouseMoveCapture: debounce, style: Object.assign(Object.assign(Object.assign({}, cssVariables), style), {
        width,
        height
      }) }, { children: [children, shouldDisplayButtons && jsxRuntime.jsx(index["default"], {})] })) }));
    }
    exports.Orchestrator = Orchestrator;
  }
});

// node_modules/hero-slider/dist/HeroSlider.js
var require_HeroSlider = __commonJS({
  "node_modules/hero-slider/dist/HeroSlider.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var jsxRuntime = require_jsx_runtime();
    var Accessibility = require_Accessibility();
    var Animations = require_Animations();
    var Autoplay = require_Autoplay();
    var Controller = require_Controller();
    var IntersectionObserver2 = require_IntersectionObserver();
    var Layout = require_Layout();
    var Manager = require_Manager();
    var Settings = require_Settings();
    var Orchestrator = require_Orchestrator();
    function HeroSlider(props) {
      return jsxRuntime.jsx(Layout.LayoutProvider, { children: jsxRuntime.jsx(Manager.ManagerProvider, Object.assign({ manager: props.manager }, { children: jsxRuntime.jsx(Settings.SettingsProvider, Object.assign({ settings: props.settings }, { children: jsxRuntime.jsx(Controller.ControllerProvider, Object.assign({ controller: props.controller }, { children: jsxRuntime.jsx(Accessibility.AccessibilityProvider, Object.assign({ accessibility: props.accessibility }, { children: jsxRuntime.jsx(Animations.AnimationsProvider, Object.assign({ animations: props.animations }, { children: jsxRuntime.jsx(IntersectionObserver2.IntersectionObserverProvider, { children: jsxRuntime.jsx(Autoplay.AutoplayProvider, Object.assign({ autoplay: props.autoplay }, { children: jsxRuntime.jsx(Orchestrator.Orchestrator, Object.assign({ className: props.className, width: props.width, height: props.height, style: props.style }, { children: props.children })) })) }) })) })) })) })) })) });
    }
    exports["default"] = HeroSlider;
  }
});
export default require_HeroSlider();
//# sourceMappingURL=hero-slider_dist_HeroSlider.js.map
